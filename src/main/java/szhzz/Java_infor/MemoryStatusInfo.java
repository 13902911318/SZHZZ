/** * MemoryStatus.java runs a background process that sleeps for a * pre-determined amount of time. When it awakens, it displays * current memory usage in a "ticker-tape" display window. * <p/> * This is closely based on StatusMemory.java by Jef Poskanzer, from * his public distribution on <http://www.acme.com> * <p/> * Copyright &copy; 1996-1998 Martin Minow. All Rights Reserved.<p> * <p/> * Permission to use, copy, modify, and redistribute this software and its * documentation for personal, non-commercial use is hereby granted provided that * this copyright notice and appropriate documentation appears in all copies. This * software may not be distributed for fee or as part of commercial, "shareware," * and/or not-for-profit endevors including, but not limited to, CD-ROM collections, * online databases, and subscription services without specific license.<p> * * @author <a href="mailto:minow@apple.com">Martin Minow</a> * @version 1.0 * Set tabs every 4 characters. */package szhzz.Java_infor;import java.awt.*;import java.util.StringTokenizer;public class MemoryStatusInfo extends Panel {    private static final int totalKIndex = 0;    private static final int usageKIndex = 1;    private static final int perSecIndex = 2;    private static final int labelCount = 3;    private static final String labelString = "Total\nUsage\nKB/Sec\n";    private Label[] valueLabels = new Label[labelCount];    private Label[] valueData = new Label[labelCount];    /*     * Here are the values we display.     */    private transient int totalK = Integer.MIN_VALUE;    private transient int usageK = Integer.MIN_VALUE;    private transient double usageKBytesPerSec = Double.MIN_VALUE;    public MemoryStatusInfo() {        setBackground(Color.white);        GridBagLayout gridbag = new GridBagLayout();        setLayout(gridbag);        StringTokenizer t = new StringTokenizer(labelString, "\n");        for (int i = 0; t.hasMoreElements(); i++) {            initializeLabel(i, t.nextToken());        }        Canvas line = new Canvas();        /*         * Add a vertical line to the right of the text as a separator		 * between the info and the ticker-tape.		 */        line.setBackground(Color.black);        line.resize(1, 1);        GridBagConstraints c = new GridBagConstraints();        c.gridx = 2;        c.gridy = 0;        c.gridwidth = 1;        c.gridheight = labelCount + 1;        c.fill = GridBagConstraints.VERTICAL;        c.anchor = GridBagConstraints.WEST;        c.weightx = 0.0;        c.weighty = 1.0;        c.insets = new Insets(0, 0, 0, 0);        gridbag.setConstraints(line, c);        add(line);        /*         * Add a blank panel that fills the space below the data.		 * (well, that's the idea, anyway).		 */        Panel blank = new Panel();        c.gridx = 0;        c.gridy = labelCount;        c.gridwidth = 2;        c.gridheight = 1;        c.fill = GridBagConstraints.BOTH;        c.anchor = GridBagConstraints.CENTER;        c.weightx = 1.0;        c.weighty = 1.0;        gridbag.setConstraints(blank, c);        add(blank);        setValues(0, 0, 0.0);    }    private void initializeLabel(            int row,            String label    ) {        valueLabels[row] = new Label(label, Label.LEFT);        valueData[row] = new Label("-00.000", Label.RIGHT);        GridBagConstraints c = new GridBagConstraints();        c.gridx = 0;        c.gridy = row;        c.gridwidth = 1;        c.gridheight = 1;        c.fill = GridBagConstraints.NONE;        c.anchor = GridBagConstraints.WEST;        c.weightx = 0.0;        c.weighty = 0.0;        c.insets = new Insets(0, 0, 0, 0);        GridBagLayout gridbag = (GridBagLayout) getLayout();        gridbag.setConstraints(valueLabels[row], c);        add(valueLabels[row]);        c.gridx = 1;        c.anchor = GridBagConstraints.EAST;        gridbag.setConstraints(valueData[row], c);        add(valueData[row]);    }    /*     * Update the label values.     */    public void setValues(            int totalK,            int usageK,            double usageKBytesPerSec    ) {        if (this.totalK != totalK) {            this.totalK = totalK;            valueData[totalKIndex].setText(Integer.toString(totalK));        }        if (this.usageK != usageK) {            this.usageK = usageK;            valueData[usageKIndex].setText(Integer.toString(usageK));        }        if (this.usageKBytesPerSec != usageKBytesPerSec) {            this.usageKBytesPerSec = usageKBytesPerSec;            StringBuffer text = new StringBuffer();            if (usageKBytesPerSec < 0) {                text.append('-');                usageKBytesPerSec = (-usageKBytesPerSec);            }            long intPart = (long) (usageKBytesPerSec + 0.5);            int fract = (int) ((usageKBytesPerSec - ((double) intPart)) * 1000.0);            text.append(Long.toString(intPart) + Integer.toString(fract + 1000));            text.setCharAt(text.length() - 4, '.');            valueData[perSecIndex].setText(text.toString());        }    }}